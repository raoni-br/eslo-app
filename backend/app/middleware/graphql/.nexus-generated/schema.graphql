### This file was generated by Nexus Schema
### Do not make changes to this file directly


union ActivateAndUpdateSubscriptionType = CustomerPaymentSettings | Subscription

input ActivateAndUpgradeSubscriptionInput {
  subscriptionId: String!
  subscriptionItems: [SubscriptionItemsInput]
}

type Activity {
  activitySlides: [MediaAssociation]
  order: Int!
  title: String!
}

input AddStudentToGroupInput {
  id: String!
  studyGroupId: String!
}

input Answer {
  key: String
  value: String
  values: [String]
}

type AppData {
  enrollments: [Enrollment]
  events: [Event]
  id: ID
  studyGroups: [StudyGroup]
  users: [User]
}

type BalanceDetails {
  discountAmount: Float
  quantity: Float
  taxAmount: Float
  totalAmount: Float
  unitPrice: Float
}

type BalanceSummary {
  discountAmount: Float
  taxAmount: Float
  totalAmount: Float
}

type Button {
  action: String
  text: String
  type: String!
}

input ChangeEventInput {
  availabilityType: String!
  changeStatus: String!
  completedAt: String
  description: String!
  endDateTime: String!
  endTimeZone: String!
  id: ID
  organiserId: String
  ownerId: String
  recurrence: String!
  sendNotifications: Boolean
  sourceType: String!
  startDateTime: String!
  startTimeZone: String!
  title: String!
  visibility: String
}

input ChangePasswordInput {
  newPassword: String
  oldPassword: String
  userEmail: String
}

input ChangeScheduleInput {
  enrollmentId: ID!
  events: [ChangeEventInput]
}

type Checkbox {
  key: String
  objects: [CheckboxObjects]
  required: Boolean
  text: String
  type: String!
}

union CheckboxObjects = Button | Option

union ClassRecord = EnrollmentClassRecord | StudyGroupClassRecord

interface ClassRecordInterface {
  completedAt: String
  deletedAt: String
  id: ID!
  lesson: Lesson!
  lessonEndedAt: String
  lessonStartedAt: String
  startedAt: String
  status: String
  teacherNotes: String
}

type Classroom {
  classInProgress: ClassRecord
  id: ID!
  studentEnrollments: [Enrollment]
  students: [Student]
  studyGroups: [StudyGroup]
}

input ClassroomFiltersInput {
  activeEnrollmentsOnly: Boolean
  studyGroupStatus: String
}

type CompanyDetails {
  address: String
  email: String
  id: ID!
  name: String
  phone: String
  webSite: String
}

type ConferenceData {
  conferenceKey: String
  conferenceUrl: String
  sourceId: String
  sourceType: String
}

input CreateProductInput {
  completedAt: String
  description: String!
  name: String!
  slug: String!
  startedAt: String
  subcategoryCode: String!
}

input CreateProductPriceInput {
  allowFreeTrial: Boolean
  completedAt: String
  currencyIsoCode: String!
  description: String!
  name: String!
  pricePeriod: PricePeriodInput
  productId: String!
  recurrence: String
  slug: String!
  startedAt: String
  taxAmount: Float!
  type: String!
  unitTotalAmount: Float!
}

input CreateStudyGroupInput {
  events: [EventInput]
  levelId: ID!
  name: String!
}

input CreateSubscriptionInput {
  subscriptionItems: [SubscriptionItemsInput]!
  type: String!
}

type CustomerDetails {
  address: String
  email: String
  id: ID!
  name: String
  phone: String
}

type CustomerPaymentSettings {
  id: ID!
  paymentProviderCheckoutSessionId: String
  paymentProviderPaymentMethodId: String
  userId: String
}

input DashboardFilters {
  enrollmentStatus: String
  subscriptionsExpiringInDays: Int
  subscriptionsStatus: String
}

type Delay {
  index: Int
  time: Int
  type: String!
}

type Dialog {
  animation: String
  key: String
  order: String
  steps: [DialogSteps]
  title: String
  type: String!
}

type DialogBox {
  key: String
  objects: [DialogObjects]
  required: Boolean
  text: String
  type: String!
}

union DialogObjects = Button | Delay | Input

union DialogSteps = DialogBox

input EditFinishedClassInput {
  attendees: [StudyGroupAttendeeInput]
  classRecordId: String!
  lessonEndedAt: String
  lessonStartedAt: String
  sourceId: String!
  sourceType: String!
  teacherNotes: String
}

type Enrollment {
  activationDate: String
  classInProgress: ClassRecord
  classRecords: [ClassRecord]
  events: [Event]
  externalKey: String
  id: ID!
  invitation: Invitation
  lastLesson: ClassRecord
  lessons: [Lesson]
  level: Level
  nextEventOccurrence: EventOccurrence
  nextLesson: Lesson
  registrationDate: String
  sourceType: String
  status: String
  student: User
  studyGroup: StudyGroup
  teacher: User
}

type EnrollmentClassRecord implements ClassRecordInterface {
  completedAt: String
  deletedAt: String
  enrollment: Enrollment
  enrollmentId: String!
  id: ID!
  lesson: Lesson!
  lessonEndedAt: String
  lessonStartedAt: String
  revertClassStatus: Boolean
  startedAt: String
  status: String
  teacherNotes: String
}

input EnrollmentInput {
  oneOnOne: OneOnOneInput
  studyGroupId: String
}

type Event {
  availabilityType: String
  completedAt: String
  conferenceData: ConferenceData
  description: String
  endDateTime: String
  endTimeZone: String
  enrollment: Enrollment
  eventAttendees: [EventAttendee]
  eventOccurrences: [EventOccurrence]
  iCalUID: String
  id: ID!
  organiser: User
  owner: User
  recurrence: String
  sendNotifications: Boolean
  sourceId: String
  sourceType: String
  startDateTime: String
  startTimeZone: String
  startedAt: String
  status: String
  title: String
  visibility: String
}

type EventAttendee {
  attendee: User
  comment: String
  id: ID!
  optional: Boolean
  organiser: Boolean
  responseDateTime: String
  responseStatus: String
}

input EventInput {
  availabilityType: String!
  completedAt: String
  description: String
  endDateTime: String!
  endTimeZone: String!
  iCalUID: String
  recurrence: String
  sendNotifications: Boolean
  sourceId: String
  sourceType: String!
  startDateTime: String!
  startTimeZone: String!
  startedAt: String
  status: String
  title: String!
  visibility: String
}

type EventOccurrence {
  availabilityType: String
  conferenceData: ConferenceData
  description: String
  endDateTime: String
  endTimeZone: String
  enrollment: Enrollment
  eventOccurrenceAttendees: [EventOccurrenceAttendee]
  iCalUID: String
  id: ID!
  organiser: User
  originalStartDateTime: String
  originalStartTimeZone: String
  owner: User
  recurringEventId: ID
  sendNotifications: Boolean
  sourceId: String
  sourceType: String
  startDateTime: String
  startTimeZone: String
  status: String
  studyGroup: StudyGroup
  title: String
  visibility: String
}

type EventOccurrenceAttendee {
  attendee: User
  comment: String
  eventOccurrenceId: String
  id: ID!
  optional: Boolean
  organiser: Boolean
  responseDateTime: String
  responseStatus: String
}

input EventOccurrenceInput {
  availabilityType: String!
  description: String!
  endDateTime: String!
  endTimeZone: String!
  id: String!
  originalStartDateTime: String!
  originalStartTimeZone: String!
  recurringEventId: String!
  sendNotifications: Boolean
  sourceId: ID!
  sourceType: String!
  startDateTime: String!
  startTimeZone: String!
  status: String!
  title: String!
  visibility: String
}

input EventsInput {
  events: [EventInput]
}

input FinishClassInput {
  attendees: [StudyGroupAttendeeInput]
  classRecordId: String!
  lessonEndedAt: String
  lessonStartedAt: String
  sourceId: String!
  sourceType: String!
  status: String
  teacherNotes: String
}

input FinishStudyGroupClassInput {
  attendees: [StudyGroupAttendeeInput]
  status: String!
  studyGroupClassRecordId: ID!
  teacherNotes: String
}

type FinishedLesson {
  finishedLesson: ClassRecord
}

type FreeTrial {
  expiringInDays: String
  trialEndedAt: String
  trialStartedAt: String
}

type Input {
  placeholder: String
  type: String!
  valueType: String
}

type Invitation {
  id: ID!
  invitee: User
  inviteeEmail: String
  inviteeFirstName: String
  inviteeSurname: String
  inviter: User
  sourceId: String
  sourceType: String
  status: String
}

type InvoiceItem {
  balance: BalanceDetails
  id: ID!
  invoiceLineNumber: Int
  productDescription: String
  productId: String
  productName: String
}

type InvoicePreview {
  balanceSummary: BalanceSummary
  companyDetails: CompanyDetails
  customerDetails: CustomerDetails
  dueDate: String
  id: ID!
  invoiceItems: [InvoiceItem]
  invoicePeriodFrom: String
  invoicePeriodTo: String
  processedAt: String
}

type Lesson {
  category: String
  code: String
  id: ID!
  lessonMaterial: LessonMaterial
  level: Level
  levelOrder: Int
  providerInfo: ProviderInfo
  slug: String
  subject: String
  title: String
}

type LessonMaterial {
  activities: [Activity]
  audio: [MediaAssociation]
  lectureScript: [MediaAssociation]
  studentBook: [MediaAssociation]
}

type Level {
  code: String
  description: String
  id: ID!
  label: String
  layoutSettings: LevelLayoutSettings
  lessons: [Lesson]
  module: Module
  moduleOrder: Int
  name: String
  providerInfo: ProviderInfo
  releasedAt: String
  removedAt: String
}

type LevelLayoutSettings {
  icon: String
  primaryColour: String
  secondaryColour: String
  svgImageUrl: String
}

type Media {
  altTxt: String
  id: ID!
  largeFilename: String
  mediumFilename: String
  mimeType: String
  rootUri: String
  smallFilename: String
  thumbnailFilename: String
}

type MediaAssociation {
  media: Media!
  order: Int!
}

type Module {
  code: String
  description: String
  id: ID!
  levels: [Level]
  name: String
  program: Program
  programOrder: Int
  providerInfo: ProviderInfo
  releasedAt: String
  removedAt: String
}

type Mutation {
  activateAndUpgradeSubscription(activateAndUpgradeSubscriptionInput: ActivateAndUpgradeSubscriptionInput): ActivateAndUpdateSubscriptionType
  activateEnrollment(
    """Enrollment ID"""
    enrollmentId: ID
  ): Enrollment
  addStudentToGroup(enrollmentInput: AddStudentToGroupInput): Enrollment
  cancelEnrollment(
    """Enrollment ID"""
    id: ID
  ): Enrollment
  changeEnrollmentSchedule(changeScheduleInput: ChangeScheduleInput): Enrollment
  changeMyPassword(changePasswordInput: ChangePasswordInput): User
  changeSpecificEvent(changeSpecificEventInput: EventOccurrenceInput): EventOccurrence
  createEnrollment(enrollmentInput: EnrollmentInput, invitedStudent: StudentInput): Enrollment
  createPaymentMethodCheckoutMutation(
    """Payment method type"""
    type: String
  ): CustomerPaymentSettings
  createProduct(createProductInput: CreateProductInput): Product
  createProductPrice(createProductPriceInput: CreateProductPriceInput): ProductPrice
  createStudyGroup(createGroupInput: CreateStudyGroupInput): StudyGroup
  createSubscription(subscriptionInput: CreateSubscriptionInput): Subscription
  editFinishedClass(editFinishedClassInput: EditFinishedClassInput): ClassRecord
  finishClass(finishClassInput: FinishClassInput): ClassRecord
  removeStudentFromGroup(
    events: EventsInput

    """Enrollment ID"""
    id: ID
  ): Enrollment
  removeStudyGroup(removeGroupInput: RemoveStudyGroupInput): StudyGroup
  revertFinishedClassStatus(revertFinishedClassStatusInput: RevertFinishedClassStatusInput): ClassRecord
  revertLessonStatus(revertLessonStatusInput: RevertLessonStatusInput): Lesson
  startClass(startClassInput: StartClassInput): ClassRecord
  submitUserTutorialForm(submitUserTutorialFormInput: SubmitUserTutorialFormInput): UserTutorialForm
  updateMyProfile(userProfile: UserInput): User
  updateProductPrice(updateProductPriceInput: UpdateProductPriceInput): ProductPrice
  updateStudyGroup(studyGroupInput: UpdateStudyGroupInput): StudyGroup
}

input OneOnOneInput {
  events: [EventInput]
  levelId: String!
}

type Option {
  hint: String
  text: String
  type: String!
  value: String
}

input PriceFilters {
  active: Boolean
}

type PricePeriod {
  interval: String!
  intervalCount: Int!
}

input PricePeriodInput {
  interval: String!
  intervalCount: Int!
}

type Product {
  description: String
  id: ID!
  name: String
  prices: [ProductPrice]
  slug: String
  subcategory: ProductSubcategory
}

type ProductCategory {
  code: ID!
  description: String
  name: String
  products: [Product]
}

input ProductFilters {
  categoryCode: String
  priceFilters: PriceFilters
}

type ProductPrice {
  currencyIsoCode: String
  description: String
  id: ID!
  name: String
  pricePeriod: PricePeriod
  slug: String
  taxAmount: Float
  type: String
  unitTotalAmount: Float
}

type ProductSubcategory {
  category: ProductCategory
  code: ID!
  description: String
  name: String
}

type Program {
  code: String
  description: String
  icon: String
  id: ID!
  label: String
  modules: [Module]
  name: String
  providerInfo: ProviderInfo
  releasedAt: String
  removedAt: String
}

type ProviderInfo {
  details: ProviderLessonDetails
  providerCode: String
  providerId: String
}

type ProviderLessonDetails {
  rexCourse: String
  rexKeyLanguage: String
  rexLanguage: String
  rexPronunciationLesson: String
}

type Query {
  adminDataExtractor: AppData
  classroom(filters: ClassroomFiltersInput): Classroom
  enrollment(
    """Enrollment ID"""
    id: ID
  ): Enrollment
  findGroupById(
    """Group ID"""
    id: String
  ): StudyGroup
  findGroupByTeacher: [StudyGroup]
  getUserTutorialForm(
    """Form slug"""
    slug: String
  ): UserTutorialForm
  invoicePreview: InvoicePreview
  lesson(
    """Lesson ID"""
    id: ID
  ): Lesson
  liveChatToken: ID
  myCalendar(
    """Start date of calendar view"""
    fromDate: String

    """End date of calendar view"""
    toDate: String
  ): [EventOccurrence]
  myProfile: User
  product(
    """Product ID"""
    id: ID
  ): Product
  products(productFilters: ProductFilters): [Product]
  program(
    """Program ID"""
    id: ID
  ): Program
  programs: [Program]
  studentDashboard(filters: DashboardFilters): StudentDashboard
  subscription(
    """Subscription ID"""
    id: ID
  ): Subscription
  teacherDashboard(filters: DashboardFilters): TeacherDashboard
  userSubscriptions: [Subscription]
}

type Question {
  animation: String
  key: String
  order: String
  steps: [QuestionSteps]
  title: String
  type: String!
}

union QuestionSteps = Checkbox | DialogBox | Radio

type Radio {
  key: String
  objects: [RadioObjects]
  required: Boolean
  text: String
  type: String!
}

union RadioObjects = Button | Option

input RemoveStudyGroupInput {
  studyGroupId: ID!
}

input RevertFinishedClassStatusInput {
  classRecordId: String!
  sourceId: String!
  sourceType: String!
}

input RevertLessonStatusInput {
  lessonId: String!
  sourceId: ID!
  sourceType: String!
}

union Section = Dialog | Question

input StartClassInput {
  lessonId: String
  levelId: String
  sourceId: String!
  sourceType: String!
  teacherNotes: String
}

input StartStudyGroupClassInput {
  lessonId: String!
  studyGroupId: ID!
  teacherNotes: String
}

type Student {
  displayName: String
  enrollments: [Enrollment]
  familyName: String
  firstName: String
  id: ID!
  primaryEmail: String
  subscriptions: [StudentSubscriptions]
}

type StudentDashboard {
  id: ID!
  nextEvent: EventOccurrence
  subscriptions: [Subscription]
}

input StudentInput {
  email: String!
  firstName: String!
  surname: String!
}

type StudentSubscriptions {
  customerId: String
  id: ID
  renewalDate: String
  status: String
  student: Student
}

type StudyGroup {
  enrollments: [Enrollment]
  events: [Event]
  id: ID!
  lastLesson: StudyGroupClassRecord
  lessons: [Lesson]
  level: Level
  name: String
  nextLesson: Lesson
  studyGroupClassRecords: [StudyGroupClassRecord]
  studyGroupTeachers: [StudyGroupTeacher]
}

input StudyGroupAttendeeInput {
  attended: Boolean
  studentId: String!
}

type StudyGroupClassAttendee {
  attended: Boolean
  classRecord: ClassRecord
  id: ID!
  student: Enrollment
  studentId: ID
  studyGroupClassRecord: StudyGroupClassRecord
}

type StudyGroupClassRecord implements ClassRecordInterface {
  completedAt: String
  deletedAt: String
  id: ID!
  lesson: Lesson!
  lessonEndedAt: String
  lessonStartedAt: String
  revertClassStatus: Boolean
  startedAt: String
  status: String
  studyGroup: StudyGroup
  studyGroupClassAttendees: [StudyGroupClassAttendee]
  studyGroupId: String!
  teacherNotes: String
}

type StudyGroupTeacher {
  id: ID!
  studyGroup: StudyGroup
  studyGroupClassRecord: [StudyGroupClassRecord]
  teacher: User
}

input SubmitUserTutorialFormInput {
  answers: [Answer]
  slug: String
}

type Subscription {
  customer: User
  customerId: String
  freeTrial: FreeTrial
  id: ID!
  paymentProviderCheckoutId: String
  paymentProviderId: String
  status: String
  subscriptionItems: [SubscriptionItem]
}

type SubscriptionItem {
  active: Boolean
  id: ID!
  priceId: String
  quantity: Float
  subscriptionId: String
}

input SubscriptionItemsInput {
  priceId: String!
  quantity: Int!
}

type TeacherDashboard {
  id: ID!
  nextEvents: [EventOccurrence]
  students: [Student]
}

input UpdateProductPriceInput {
  allowFreeTrial: Boolean
  currencyIsoCode: String
  description: String
  name: String
  priceId: String!
  pricePeriod: PricePeriodInput
  recurrence: String
  slug: String!
  taxAmount: Float!
  type: String
  unitTotalAmount: Float!
}

input UpdateStudyGroupInput {
  events: [ChangeEventInput]
  name: String!
  studyGroupId: ID!
}

type User {
  dateOfBirth: String
  displayName: String
  eventsOrganised: [Event]
  eventsOwned: [Event]
  familyName: String
  firstName: String
  id: ID!
  invitationsReceived: [Invitation]
  onboardingSubmitted: Boolean
  primaryEmail: String
  profileComplete: Boolean
  userAddresses: [UserAddress]
  userIdentificationList: [UserIdentification]
  userPhoneNumbers: [UserPhoneNumber]
}

type UserAddress {
  addressType: String
  city: String
  countryISO: String
  district: String
  id: ID!
  latitude: Float
  longitude: Float
  postalCode: String
  state: String
  street: String
  streetComplement: String
  streetNumber: String
}

input UserAddressInput {
  addressType: String
  city: String
  countryISO: String
  district: String
  id: ID
  latitude: Float
  longitude: Float
  postalCode: String
  state: String
  street: String
  streetComplement: String
  streetNumber: String
}

type UserIdentification {
  attachementUrl: String
  category: String
  code: String
  countryISO: String
  id: ID!
}

input UserIdentificationInput {
  attachementUrl: String
  category: String
  code: String
  countryISO: String
  id: ID
}

input UserInput {
  displayName: String
  familyName: String
  firstName: String
  primaryEmail: String
  profileComplete: Boolean
  userAddresses: [UserAddressInput]
  userIdentificationList: [UserIdentificationInput]
}

type UserPhoneNumber {
  category: String
  code: String
  countryISO: String
  id: ID!
  internationalFormat: String
  nationalFormat: String
  rawFormat: String
}

input UserPhoneNumberInput {
  category: String
  code: String
  countryISO: String
  id: ID
  internationalFormat: String
  nationalFormat: String
  rawFormat: String
}

type UserTutorialForm {
  description: String
  id: ID!
  sections: [Section]
  slug: String
  title: String
}
